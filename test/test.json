{
    "name": "Test - TCP session info tracker",
    "code": "/**\n * eBPF C program to be dynamically injected in the kernel.\n * The aim of this program is to extract some info concerning many packets passing through the interface in order to prevent a possible attack.\n * By now the following protocols are checked:\n *  - TCP\n *  - UDP\n *  - ICMP\n */\n/*Protocol types according to standard*/\n#define IPPROTO_TCP 6\n#define IPPROTO_UDP 17\n#define IPPROTO_ICMP 1\n\n/*Own control variables*/\n#define N_PACKET 10000\n#define N_SESSION 10240\n#define RESTART_TIME 10000000000\n\n/*TCP-SESSION identifier*/\nstruct tcp_session {\n    __be32  saddr;\n    __be32  daddr;\n    __be16  sport;\n    __be16  dport;\n} __attribute__((packed));\n\n/*Structure containing info about capture and valid indexes*/\nstruct capture_info {\n    unsigned int feature_map_index;\n    unsigned int n_session_tracking;\n    uint64_t last_ins_tstamp;\n} __attribute__((packed));\n\n/*Features to be exported*/\nstruct features {\n    uint32_t saddr;         //IP source address\n    uint32_t daddr;         //IP destination address\n    uint64_t timestamp;     //Packet timestamp\n    uint16_t length;        //IP length value\n    uint16_t ipv4_flags;    //IP flags\n    uint16_t tcp_len;       //TCP payload length\n    uint32_t tcp_ack;       //TCP ack n\u00b0\n    uint8_t  tcp_flags;     //TCP flags\n    uint16_t tcp_win;       //TCP window value\n    uint8_t udp_len;        //UDP payload length\n    uint8_t  icmp_type;     //ICMP operation type\n} __attribute__((packed));\n\n/*Ethernet Header*/\nstruct eth_hdr {\n    __be64 dst   : 48;\n    __be64 src   : 48;\n    __be16 proto;\n} __attribute__((packed));\n\n/*Ip Header*/\nstruct iphdr {\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n    __u8    ihl:4,\n        version:4;\n#elif defined (__BIG_ENDIAN_BITFIELD)\n    __u8    version:4,\n        ihl:4;\n#else\n#error  \"Please fix <asm/byteorder.h>\"\n#endif\n    __u8    tos;\n    __be16  tot_len;\n    __be16  id;\n    __be16  frag_off;\n    __u8    ttl;\n    __u8    protocol;\n    __sum16 check;\n    __be32  saddr;\n    __be32  daddr;\n    /*The options start here. */\n} __attribute__((packed));\n\n/*TCP Header*/\nstruct tcphdr {\n    __be16  source;\n    __be16  dest;\n    __be32  seq;\n    __be32  ack_seq;\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n    __u16   res1:4,\n        doff:4,\n        fin:1,\n        syn:1,\n        rst:1,\n        psh:1,\n        ack:1,\n        urg:1,\n        ece:1,\n        cwr:1;\n#elif defined(__BIG_ENDIAN_BITFIELD)\n    __u16   doff:4,\n        res1:4,\n        cwr:1,\n        ece:1,\n        urg:1,\n        ack:1,\n        psh:1,\n        rst:1,\n        syn:1,\n        fin:1;\n#else\n#error  \"Adjust your <asm/byteorder.h> defines\"\n#endif  \n    __be16  window;\n    __sum16 check;\n    __be16  urg_ptr;\n} __attribute__((packed));\n\n/*UDP Header*/\nstruct udphdr {\n    __be16  source;\n    __be16  dest;\n    __be16  len;\n    __sum16 check;\n} __attribute__((packed));\n\n/*ICMP Header*/\nstruct icmphdr {\n  __u8      type;\n  __u8      code;\n  __sum16   checksum;\n  union {\n    struct {\n        __be16  id;\n        __be16  sequence;\n    } echo;\n    __be32  gateway;\n    struct {\n        __be16  __unused;\n        __be16  mtu;\n    } frag;\n    __u8    reserved[4];\n  } un;\n} __attribute__((packed));\n\n/*Structure used as initializer*/\nstatic const struct features EmptyFeatures;\n\n/*Structures shared between Control Plane - Data Plane*/\nBPF_ARRAY(CAPTURE_INFO, struct capture_info, 1);\nBPF_ARRAY(PACKET_FEATURE_MAP, struct features, N_PACKET);\n/*Tracked session map*/\nBPF_TABLE(\"lru_hash\", struct tcp_session, u8, TCP_SESSIONS_TRACKED, N_SESSION);\n\nstatic __always_inline int handle_rx(struct CTXTYPE *ctx, struct pkt_metadata *md) {\n    void *data = (void *) (long) ctx->data;\n    void *data_end = (void *) (long) ctx->data_end;\n \t\n    /*Parsing L2*/\n    struct eth_hdr *ethernet = data;\n    if (data + sizeof(*ethernet) > data_end)\n        return RX_OK;\n\n    if (ethernet->proto != bpf_htons(ETH_P_IP))\n        return RX_OK;\n\n    /*Parsing L3*/\n    struct iphdr *ip = data + sizeof(struct eth_hdr);\n    if (data + sizeof(struct eth_hdr) + sizeof(*ip) > data_end)\n        return RX_OK;\n    if ((int) ip->version != 4)\n        return RX_OK;\n\n    /*Checking for considered protocols*/\n    if(ip->protocol != IPPROTO_TCP && ip->protocol != IPPROTO_UDP && ip->protocol != IPPROTO_ICMP){\n \t\treturn RX_OK;\n \t}\n\n \t/*Retrieving capture information*/\n    unsigned int key = 0;\n    struct capture_info *cinfo = CAPTURE_INFO.lookup(&key);\n    if (!cinfo){\n        return RX_OK;\n    }\n\n    /*Checking if packed is already timestamped, otherwise get it from kernel bpf function*/\n    uint64_t curr_time = ctx->tstamp == 0? bpf_ktime_get_ns() : ctx->tstamp;\n\n    /*Checking if array of captured packets is full*/\n    if(cinfo->feature_map_index == N_PACKET) {\n        /*Checking if last insertion happened 10s ago*/\n        if(curr_time - cinfo->last_ins_tstamp < RESTART_TIME) {\n            return RX_OK;\n        }\n        /*Reset head to zero to start extracting packet feature again*/\n        cinfo->feature_map_index = 0;\n    }\n\n    /*Retrieving current features slot*/\n    struct features *pkt_info =  PACKET_FEATURE_MAP.lookup(&cinfo->feature_map_index);\n    if (!pkt_info){\n        return RX_OK;\n    }\n\n    /*Calculating ip header length\n     * value to multiply *4\n     *e.g. ip->ihl = 5 ; TCP Header starts at = 5 x 4 byte = 20 byte */\n    uint8_t ip_header_len = ip->ihl << 2;   //SHL 2 -> *4 multiply\n\n    switch(ip->protocol) {\n    \tcase IPPROTO_TCP: {\n            /*Parsing L4 TCP*/\n    \t\tstruct tcphdr *tcp = data + sizeof(struct eth_hdr) + ip_header_len;\n\t\t \tif((void *)tcp + sizeof(*tcp) > data_end) {\n \t\t\t\treturn RX_OK;\n            }\n            /*Check if it is already tracked*/\n            struct tcp_session session = {.saddr=ip->saddr, .daddr=ip->daddr, .sport=tcp->source, .dport=tcp->dest};\n            u8 *is_tracked = TCP_SESSIONS_TRACKED.lookup(&session);\n            if(!is_tracked) {\n                /*Increase tracked sessions and store current one in map*/\n                u8 val = 1;\n                TCP_SESSIONS_TRACKED.insert(&session, &val);\n                cinfo->n_session_tracking+=1;\n            }/* else {\n                //Don't know actually what to do with that counter\n                *is_tracked+=1;\n            }*/\n    \n            /*Now that I'm sure to take this packet reset the structure (could contain old data)*/\n            *pkt_info = EmptyFeatures;\n            pkt_info->length = bpf_ntohs(ip->tot_len);\n            pkt_info->tcp_ack = tcp->ack_seq;\n \t\t\tpkt_info->tcp_win = bpf_ntohs(tcp->window);\n \t\t\tpkt_info->tcp_len = (uint16_t)(pkt_info->length - ip_header_len - sizeof(*tcp));\n \t\t\tpkt_info->tcp_flags = (tcp->cwr << 7) | (tcp->ece << 6) | (tcp->urg << 5) | (tcp->ack << 4)\n \t\t\t \t\t\t\t\t| (tcp->psh << 3)| (tcp->rst << 2) | (tcp->syn << 1) | tcp->fin;\n \t\t\tbreak;\n    \t}\n    \tcase IPPROTO_ICMP: {\n            /*Parsing L4 ICMP*/\n            struct icmphdr *icmp = data + sizeof(struct eth_hdr) + ip_header_len;\n            if((void *)icmp + sizeof(*icmp) > data_end) {\n                return RX_OK;\n            }\n            /*Now that I'm sure to take this packet reset the structure (could contain old data)*/\n            *pkt_info = EmptyFeatures;\n            pkt_info->length = bpf_ntohs(ip->tot_len);\n            pkt_info->icmp_type = icmp->type;\n    \t\tbreak;\n        }\n    \tcase IPPROTO_UDP: {\n            /*Parsing L4 UDP*/\n            struct udphdr *udp = data + sizeof(struct eth_hdr) + ip_header_len;\n            if((void *)udp + sizeof(*udp) > data_end) {\n                return RX_OK;\n            }\n            /*Now that I'm sure to take this packet reset the structure (could contain old data)*/\n            *pkt_info = EmptyFeatures;\n            pkt_info->length = bpf_ntohs(ip->tot_len);\n            pkt_info->udp_len = bpf_ntohs(udp->len) - sizeof(*udp);\n    \t\tbreak;\n        }\n        /*Should never reach this code since already checked*/\n        default : {\n            return RX_OK;\n        }\n    }\n\n    /*Setting packet features*/\n    pkt_info->timestamp = curr_time;\n    pkt_info->saddr = bpf_ntohl(ip->saddr);\n    pkt_info->daddr = bpf_ntohl(ip->daddr);\n    pkt_info->ipv4_flags = bpf_ntohs(ip->frag_off);\n   \n    /*The capture was fine, update last timestamp and index*/\n    cinfo->last_ins_tstamp = curr_time;\n    cinfo->feature_map_index+=1;\n\n\treturn RX_OK;\n}",
    "metrics": [
        {
            "name": "CAPTURE_INFO",
            "map-name": "CAPTURE_INFO",
            "open-metrics-metadata": {
                "help": "This metric represents the index of the last packet.",
                "type": "counter",
                "labels": []
            }
        }
    ]
}