{
    "name": "Packets feature extractor",
    "code": "\/**\r\n * eBPF C program to be dynamically injected in the kernel.\r\n * The aim of this program is to extract some info concerning many packets passing through the interface in order to prevent a possible attack.\r\n * By now the following protocols are checked:\r\n *  - TCP\r\n *  - UDP\r\n *  - ICMP\r\n * It still lacks of decision making about which TCP session should be tracked (WIP).\r\n *\/\r\n\/*Protocol types according to standard*\/\r\n#define IPPROTO_TCP 6\r\n#define IPPROTO_UDP 17\r\n#define IPPROTO_ICMP 1\r\n\r\n\/*Own control variables*\/\r\n#define N_PACKET 20\r\n#define N_SESSION 10240\r\n\r\n\/*TCP-SESSION identifier*\/\r\nstruct tcp_session {\r\n    __be32  saddr;\r\n    __be32  daddr;\r\n    __be16  sport;\r\n    __be16  dport;\r\n} __attribute__((packed));\r\n\r\n\/*Structure containing info about capture and valid indexes*\/\r\nstruct capture_info {\r\n    unsigned int feature_map_index;\r\n    unsigned int n_session_tracking;\r\n    uint64_t last_ins_tstamp;\r\n} __attribute__((packed));\r\n\r\n\r\n\/*Features to be exported*\/\r\nstruct features {\r\n    uint32_t saddr;\r\n    uint32_t daddr;\r\n    uint64_t timestamp;\r\n    uint16_t length;\r\n    uint16_t ipv4_flags;\r\n    uint16_t tcp_len;\r\n    uint32_t tcp_ack;\r\n    uint8_t  tcp_flags;\r\n    uint16_t tcp_win;\r\n    \/*\r\n    uint8_t udp_len;\r\n    uint8_t  icmp_type;\r\n    *\/\r\n} __attribute__((packed));\r\n\r\n\/*Ethernet Header*\/\r\nstruct eth_hdr {\r\n    __be64 dst   : 48;\r\n    __be64 src   : 48;\r\n    __be16 proto;\r\n} __attribute__((packed));\r\n\r\n\/*Ip Header*\/\r\nstruct iphdr {\r\n#if defined(__LITTLE_ENDIAN_BITFIELD)\r\n    __u8    ihl:4,\r\n        version:4;\r\n#elif defined (__BIG_ENDIAN_BITFIELD)\r\n    __u8    version:4,\r\n        ihl:4;\r\n#else\r\n#error  \"Please fix <asm\/byteorder.h>\"\r\n#endif\r\n    __u8    tos;\r\n    __be16  tot_len;\r\n    __be16  id;\r\n    __be16  frag_off;\r\n    __u8    ttl;\r\n    __u8    protocol;\r\n    __sum16 check;\r\n    __be32  saddr;\r\n    __be32  daddr;\r\n    \/*The options start here. *\/\r\n};\r\n\r\n\/*TCP Header*\/\r\nstruct tcphdr {\r\n    __be16  source;\r\n    __be16  dest;\r\n    __be32  seq;\r\n    __be32  ack_seq;\r\n#if defined(__LITTLE_ENDIAN_BITFIELD)\r\n    __u16   res1:4,\r\n        doff:4,\r\n        fin:1,\r\n        syn:1,\r\n        rst:1,\r\n        psh:1,\r\n        ack:1,\r\n        urg:1,\r\n        ece:1,\r\n        cwr:1;\r\n#elif defined(__BIG_ENDIAN_BITFIELD)\r\n    __u16   doff:4,\r\n        res1:4,\r\n        cwr:1,\r\n        ece:1,\r\n        urg:1,\r\n        ack:1,\r\n        psh:1,\r\n        rst:1,\r\n        syn:1,\r\n        fin:1;\r\n#else\r\n#error  \"Adjust your <asm\/byteorder.h> defines\"\r\n#endif  \r\n    __be16  window;\r\n    __sum16 check;\r\n    __be16  urg_ptr;\r\n};\r\n\r\n\/*UDP Header*\/\r\nstruct udphdr {\r\n    __be16  source;\r\n    __be16  dest;\r\n    __be16  len;\r\n    __sum16 check;\r\n};\r\n\r\n\/*ICMP Header*\/\r\nstruct icmphdr {\r\n  __u8      type;\r\n  __u8      code;\r\n  __sum16   checksum;\r\n  union {\r\n    struct {\r\n        __be16  id;\r\n        __be16  sequence;\r\n    } echo;\r\n    __be32  gateway;\r\n    struct {\r\n        __be16  __unused;\r\n        __be16  mtu;\r\n    } frag;\r\n    __u8    reserved[4];\r\n  } un;\r\n};\r\n\r\nstatic struct tcp_session EmptyStruct;\r\n\r\n\/*Structures shared between Control Plane - Data Plane*\/\r\nBPF_ARRAY(CAPTURE_INFO, struct capture_info, 1);\r\nBPF_ARRAY(PACKET_FEATURE_MAP, struct features, N_PACKET);\r\n\/*Internal structure to check whether a session is tracked or not*\/\r\nBPF_HASH(TCP_SESSIONS_TRACKED, struct tcp_session, u64, N_SESSION);\r\nBPF_ARRAY(CAPTURE_INFO, struct tcp_session[N_SESSION], 1);\r\n\r\nstatic __always_inline int handle_rx(struct CTXTYPE *ctx, struct pkt_metadata *md) {\r\n    void *data = (void *) (long) ctx->data;\r\n    void *data_end = (void *) (long) ctx->data_end;\r\n \t\r\n    \/*Parsing L2*\/\r\n    struct eth_hdr *ethernet = data;\r\n    if (data + sizeof(*ethernet) > data_end)\r\n        return RX_OK;\r\n\r\n    if (ethernet->proto != bpf_htons(ETH_P_IP))\r\n        return RX_OK;\r\n\r\n    \/*Parsing L3*\/\r\n    struct iphdr *ip = data + sizeof(struct eth_hdr);\r\n    if (data + sizeof(struct eth_hdr) + sizeof(*ip) > data_end)\r\n        return RX_OK;\r\n    if ((int) ip->version != 4)\r\n        return RX_OK;\r\n\r\n    \/*Checking for considered protocols*\/\r\n    if(ip->protocol != IPPROTO_TCP && ip->protocol != IPPROTO_UDP && ip->protocol != IPPROTO_ICMP){\r\n \t\treturn RX_OK;\r\n \t}\r\n\r\n \t\/*Retrieving capture information*\/\r\n \tunsigned int key = 0;\r\n \tstruct capture_info *cinfo = CAPTURE_INFO.lookup(&key);\r\n \tif (!cinfo){\r\n    \treturn RX_OK;\r\n \t}\r\n\r\n    \/*Checking if packed is already timestamped, otherwise get it from kernel bpf function*\/\r\n    uint64_t curr_time = ctx->tstamp == 0? bpf_ktime_get_ns() : ctx->tstamp;\r\n\r\n    \/*Checking if array of captured packets is full*\/\r\n    if(cinfo->feature_map_index == N_PACKET) {\r\n        \/*Checking if last insertion happened 10s ago*\/\r\n        if(curr_time - cinfo->last_ins_tstamp < 10000000000) {\r\n            pcn_log(ctx, LOG_TRACE, \"Number of packet to be stored reached!\");\r\n            return RX_OK;\r\n        }\r\n        \/*Reset head to zero to start extracting packet feature again*\/\r\n        cinfo->feature_map_index = 0;\r\n        \/*If reached max session to be tracked flush the table*\/\r\n        \/*TODO: dig deeper for BPF_MAP_TYPE_LRU_HASH*\/\r\n        if(cinfo->n_session_tracking == N_SESSION) {\r\n            for(int i=0; i<N_SESSION; i++) {\r\n                TCP_SESSIONS_TRACKED.delete(&cinfo->tracked_sessions[i]);\r\n                cinfo->tracked_sessions[i] = EmptyStruct;\r\n            }\r\n            cinfo->n_session_tracking = 0;\r\n        }\r\n        pcn_log(ctx, LOG_TRACE, \"Enough time passed, RESTARTING FROM INDEX 0!\");\r\n    }\r\n\r\n    \/*Retrieving current features slot*\/\r\n \tstruct features *pkt_info =  PACKET_FEATURE_MAP.lookup(&cinfo->feature_map_index);\r\n \tif (!pkt_info){\r\n    \treturn RX_OK;\r\n \t}\r\n\r\n    switch(ip->protocol) {\r\n    \tcase IPPROTO_TCP: {\r\n            \/*Parsing L4 TCP*\/\r\n    \t\tstruct tcphdr *tcp = data + sizeof(struct eth_hdr) + sizeof(struct iphdr);\r\n\t\t \tif(data + sizeof(struct eth_hdr) + sizeof(struct iphdr) + sizeof(*tcp) > data_end) {\r\n \t\t\t\treturn RX_OK;\r\n            }\r\n            \/*Check if it is already tracked*\/\r\n            struct tcp_session session = {.saddr=ip->saddr, .daddr=ip->daddr, .sport=tcp->source, .dport=tcp->dest};\r\n            uint64_t *is_tracked = TCP_SESSIONS_TRACKED.lookup(&session);\r\n            if(!is_tracked) {\r\n                \/*Check if already tracking enough session*\/\r\n                if(cinfo->n_session_tracking == N_SESSION) {\r\n                    pcn_log(ctx, LOG_TRACE, \"Number of session tracked reached!\");\r\n                    return RX_OK;\r\n                }\r\n                \/*Increase tracked sessions and store current one in map*\/\r\n                uint64_t val = cinfo->n_session_tracking;\r\n                TCP_SESSIONS_TRACKED.insert(&session, &val);\r\n                \/*Always true but required from compiler*\/\r\n                if(cinfo->n_session_tracking >= 0 && cinfo->n_session_tracking < N_SESSION) {\r\n                    cinfo->tracked_sessions[cinfo->n_session_tracking] = session;\r\n                }\r\n                cinfo->n_session_tracking+=1;\r\n                pcn_log(ctx, LOG_TRACE, \"New tracked session {%u, %u, %u, %u}\", session.saddr, session.daddr, session.sport, session.dport);\r\n            } else {\r\n                pcn_log(ctx, LOG_TRACE, \"Already tracking session {%u, %u, %u, %u}\", session.saddr, session.daddr, session.sport, session.dport);\r\n            }\r\n            \r\n            \/*Updating last inserted packet timestamp*\/\r\n            cinfo->last_ins_tstamp = curr_time;\r\n\r\n            \/*Setting packet features*\/\r\n            pkt_info->tcp_ack = tcp->ack_seq;\r\n \t\t\tpkt_info->tcp_win = bpf_ntohs(tcp->window);\r\n \t\t\tpkt_info->tcp_len = (uint16_t)(pkt_info->length - sizeof(struct iphdr) - sizeof(*tcp));\r\n \t\t\tpkt_info->tcp_flags = (tcp->cwr << 7) | (tcp->ece << 6) | (tcp->urg << 5) | (tcp->ack << 4)\r\n \t\t\t \t\t\t\t\t| (tcp->psh << 3)| (tcp->rst << 2) | (tcp->syn << 1) | tcp->fin;\r\n \t\t\tbreak;\r\n    \t}\r\n        default : {\r\n            return RX_OK;\r\n        }\r\n        \/*\r\n    \tcase IPPROTO_ICMP: {\r\n            \/\/Parsing L4 ICMP\r\n            struct icmphdr *icmp = data + sizeof(struct eth_hdr) + sizeof(struct iphdr);\r\n            if(data + sizeof(struct eth_hdr) + sizeof(struct iphdr) + sizeof(*icmp) > data_end) {\r\n                return RX_OK;\r\n            }\r\n            pkt_info->icmp_type = icmp->type;\r\n            pcn_log(ctx, LOG_INFO, \"Inserted ICMP packet at index: %d \", *CAPTURE_INFO);\r\n    \t\tbreak;\r\n        }\r\n    \tcase IPPROTO_UDP: {\r\n            \/\/Parsing L4 UDP\r\n            struct udphdr *udp = data + sizeof(struct eth_hdr) + sizeof(struct iphdr);\r\n            if(data + sizeof(struct eth_hdr) + sizeof(struct iphdr) + sizeof(*udp) > data_end) {\r\n                return RX_OK;\r\n            }\r\n            pkt_info->udp_len = bpf_ntohs(udp->len);\r\n            pcn_log(ctx, LOG_INFO, \"Inserted UDP packet at index: %d \", *CAPTURE_INFO);\r\n    \t\tbreak;\r\n        }*\/\r\n    }\r\n\r\n    \/*Setting packet features*\/\r\n    pkt_info->saddr = bpf_ntohl(ip->saddr);\r\n    pkt_info->daddr = bpf_ntohl(ip->daddr);\r\n    pkt_info->length = bpf_ntohs(ip->tot_len);\r\n    pkt_info->ipv4_flags = bpf_ntohs(ip->frag_off);\r\n    pkt_info->timestamp = curr_time;\r\n\r\n    pcn_log(ctx, LOG_TRACE, \"Inserted Packet at index: %u \", cinfo->feature_map_index);\r\n\r\n    \/*The capture was fine so increase the index*\/\r\n    cinfo->feature_map_index+=1;\r\n\r\n\treturn RX_OK;\r\n}",
    "metrics": [
        {
            "name": "CAPTURE_INFO",
            "map-name": "CAPTURE_INFO",
            "open-metrics-metadata": {
                "help": "This metric represents the index of the last packet.",
                "type": "counter",
                "labels": []
            }
        },
        {
            "name": "PACKET_FEATURE_MAP",
            "map-name": "PACKET_FEATURE_MAP",
            "open-metrics-metadata": {
                "help": "This metric represents the packets' features.",
                "type": "counter",
                "labels": []
            }
        }
    ]
}